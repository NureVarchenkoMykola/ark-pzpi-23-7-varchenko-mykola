Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Звіт
з лабораторної роботи №2
з предмету «Аналіз та рефакторинг коду»





Виконав: 
ст. гр. ПЗПІ 23-7
Варченко Микола Миколайович

Прийняв:
Дашенков Д.С.







Харків 2025
    1 Будова програмної системи
     1.1 Технологічний стек та інфраструктура розгортання
     Програмна система для контролю енергоспоживання реалізована як вебзастосунок з клієнт серверною архітектурою. Користувач взаємодіє з системою через клієнтський інтерфейс у браузері, а серверна частина приймає запити, виконує бізнес логіку та працює з базою даних. Такий підхід відповідає вимогам до доступності, оскільки система не потребує складного встановлення на кожний пристрій, і водночас забезпечує можливість централізовано керувати даними, правилами розрахунків і механізмами безпеки.
     Серверна частина побудована на Node.js із використанням Express.js як прикладного фреймворка. Це дозволило організувати чітку структуру маршрутів для різних підсистем, зокрема автентифікації, керування електроприладами, тарифами, записами споживання, лімітами та звітністю. Уся взаємодія з клієнтом відбувається через HTTP запити у форматі JSON, а відповіді повертають або дані, або повідомлення про помилки валідації. Для контролю доступу використовується токенна автентифікація на основі JWT, тому більшість операцій виконуються лише після успішного входу в систему.
     Логіка серверної частини орієнтована на предметну область обліку енергії. Система зберігає дані про користувача, створені ним прилади, вибрані або налаштовані тарифи, а також записи споживання. На основі цих записів сервер формує аналітичні підсумки за період, групування по днях і розподіл по приладах. Окремо реалізовано роботу з лімітами, де система відстежує використання кіловат годин у межах заданого періоду, визначає відсоток використання та формує статуси досягнення порогу або перевищення ліміту. Важливо, що ліміти мають періодичність і в системі реалізовано автоматичне визначення кінця періоду для тижня, місяця та року на основі дати початку, а довільний період підтримується через тип custom.
              
              
     1.2 Технологічний стек та інфраструктура розгортання
     У межах роботи було використано MySQL як реляційну систему керування базами даних. Вибір MySQL обґрунтований тим, що вона добре підходить для структурованих даних, підтримує зв’язки між сутностями, забезпечує цілісність через зовнішні ключі та дозволяє ефективно виконувати агрегації для звітів. Для локального середовища розробки застосовано XAMPP, який надав готовий набір інструментів для запуску MySQL і зручного адміністрування через phpMyAdmin. Це спростило створення таблиць, перевірку даних, імпорт і експорт, а також швидке відновлення бази під час тестування.
     Доступ до MySQL з серверної частини організовано через ORM, а саме через Sequelize. Такий підхід дав змогу працювати з таблицями як з моделями, описувати поля та зв’язки на рівні коду, а також будувати запити у вигляді викликів методів замість ручного написання SQL у кожному місці. При цьому для окремих звітів, де потрібні складні агрегації та об’єднання, використано прямі SQL запити через sequelize.query, що дозволило точніше керувати групуванням та підрахунками.
     Для документування серверного інтерфейсу використано Swagger, який формував OpenAPI специфікацію. Специфікація генерується з коментарів у файлах маршрутів і відображається у браузері як інтерактивна документація. Це дозволяє тестувати методи без сторонніх інструментів, перевіряти параметри запитів і одразу бачити структуру відповідей.
     1.3 Структура серверного проєкту та логіка модулів
     Код серверної частини організований навколо модулів, які відповідають підсистемам предметної області. Маршрути згруповані за змістом, наприклад окремо винесено автентифікацію, роботу з приладами, тарифами, записами споживання, лімітами та звітами. Кожний маршрут відповідає за обробку запиту, перевірку вхідних даних, звернення до моделей бази даних та формування результату у стандартизованому вигляді. Вхідні параметри, зокрема дати та числові значення, проходять валідацію, щоб система не приймала некоректні формати і не створювала помилкових записів.
     Окрему роль відіграють middleware компонент. Головний і єдиний забезпечує авторизацію, зчитує токен, перевіряє його коректність і додає інформацію про користувача до запиту. Завдяки цьому всі захищені маршрути можуть працювати з даними лише в межах поточного користувача, що забезпечує ізоляцію даних між різними обліковими записами. Додатково важливою є уніфікація помилок, тому сервер повертає зрозумілі повідомлення при порушенні правил валідації або при спробах виконати заборонені дії.
     Підсистема звітів реалізує декілька видів аналітики. Підсумковий звіт за період повертає загальні кіловат години та вартість, середні значення на день і на запис, а також день з найбільшим споживанням. Денний звіт агрегує дані по кожній даті та показує сумарні значення. Звіт по приладах групує записи за конкретними електроприладами, додає назву приладу та дозволяє швидко побачити розподіл витрат. Окремо існує звіт по лімітах, який повертає стан кожного ліміту, використання, залишок та статуси, а також підтримує фільтри за типом періоду, набором ідентифікаторів і статусом.
     1.4 Доменно дані моделі та взаємозв’язки
     Будова системи опирається на набір основних сутностей, які безпосередньо відображають предметну область енергоспоживання. Центральною є сутність користувача, оскільки всі інші дані належать конкретному обліковому запису. Користувач створює електроприлади, які зберігають назву та опис, а за потреби можуть містити додаткові атрибути для оцінки потужності. Записи споживання фіксують дату, величину спожитих кіловат годин, застосовану ціну за кіловат годину та підсумкову вартість, а також можуть містити примітки. Запис може бути прив’язаний до конкретного приладу, щоб у майбутньому було можливо будувати деталізовані розподіли.
     Тарифи моделюють правила ціноутворення і містять значення ціни за кіловат годину та період дії. Це дає змогу зберігати історію тарифів і коректно розраховувати вартість для записів споживання, навіть якщо тариф змінювався з часом. Ліміти описують бажане обмеження споживання на певний період і містять величину ліміту, тип періоду, дату початку і дату завершення, а також параметри сповіщень. У системі реалізовано логіку, яка за датою початку автоматично визначає дату завершення для типів week, month і year, а довільний період підтримується через custom, де дата завершення задається вручну.
     У сукупності ці сутності утворюють цілісну структуру даних, де користувач є власником приладів, тарифів, записів споживання та лімітів, а серверна частина забезпечує контроль доступу, перевірку коректності даних, обчислення вартості та формування аналітичних звітів на основі агрегованих запитів до MySQL.
    2 UML діаграма прецедентів для серверної частини
     2.1 Призначення діаграми та межі серверної частини
     UML діаграма прецедентів показує, які дії користувач може виконувати через сервер і які серверні функції потрібні для цього. У нашій системі контролю енергоспоживання серверна частина відповідає за автентифікацію, збереження даних у базі MySQL, перевірку коректності введених значень, розрахунок показників споживання і вартості, а також формування звітів і експорт результатів. Діаграма фіксує саме ті сценарії, які реалізовані як API запити до серверу та обробляються логікою застосунку.

Рис. 1 – UML діаграма
     2.2 Актор та основні прецеденти користувача
     На діаграмі є один актор Користувач. Це узагальнений користувач системи, який працює зі своїм обліковим записом і власними даними про споживання. До основних прецедентів належать реєстрація та вхід у систему. Вони потрібні, щоб сервер міг створити обліковий запис, перевірити пароль і видати токен доступу для подальших запитів.
     Після авторизації користувач працює з декількома великими групами даних. Перша група це записи споживання, де доступні додавання, перегляд історії, редагування та видалення записів. Друга група це електроприлади, де користувач може додати прилад, переглянути список, редагувати або видалити прилад. Третя група це тарифи, де користувач налаштовує тариф, переглядає історію тарифів і за потреби редагує тарифні значення. Окремо на діаграмі показані сценарії аналітики та звітності, де користувач переглядає статистику, формує звіт за період, порівнює періоди споживання або дивиться розподіл по приладах. Також наявна група, де встановлюються ліміти споживання та відслідковуються їх прогреси.
     2.3 Включені прецеденти та логіка include
     На діаграмі присутні зв’язки include, які позначають повторно використовувані частини поведінки серверної логіки. Найбільш типові включення пов’язані з двома службовими діями, які потрібні в багатьох сценаріях.
     Перше включення це валідація введених даних. Вона підключається до операцій, де користувач надсилає на сервер нові значення або змінює існуючі. Це стосується додавання або редагування записів споживання, створення або оновлення приладів, налаштування тарифу, а також створення лімітів. Сервер перевіряє формат дат, числові значення кіловат годин, логіку періодів, обов’язковість полів і зв’язки з поточним користувачем, щоб дані були коректні і не псували розрахунки.
     Друге включення це розрахунок вартості споживання. Він пов’язаний із тим, що при роботі з записами споживання і при формуванні звітів сервер має визначати суму витрат на основі кіловат годин та актуального тарифу.
     2.4 Зв’язок діаграми з реалізованим API
     Діаграма прецедентів узгоджується з тим, як побудовані наші серверні маршрути та ендпоінти. Авторизаційні дії відповідають окремим запитам реєстрації та входу, після яких клієнт використовує токен доступу. Операції над записами споживання, приладами, тарифами і лімітами реалізовані як окремі групи API ендпоінтів, а сценарії звітів і експорту реалізовані у вигляді звітних ендпоінтів, включно з отриманням агрегованих даних за період і формуванням CSV файлів. Таким чином діаграма слугує компактним описом того, які можливості надає сервер, і чому потрібні окремі модулі перевірки даних та обчислень у бізнес логіці.
    3 ER діаграма 
     3.1 Загальна структура даних та призначення сутностей

Рис. 2 – ER діаграма

     ER діаграма відображає реляційну модель даних для серверної частини системи контролю енергоспоживання. У центрі моделі знаходиться сутність Users, оскільки всі дані в системі належать конкретному користувачу та ізолюються за його ідентифікатором. Це забезпечує коректну роботу багатокористувацького режиму та дозволяє зберігати історію обліку споживання окремо для кожного облікового запису.
     Сутність Appliances описує електроприлади, які додає користувач, наприклад бойлер, холодильник або освітлення. Кожен прилад має власну назву та додаткові характеристики, які потрібні для зручного ведення обліку та подальшого аналізу. Сутність Tariffs зберігає тарифи користувача, тобто вартість за кіловат годину та період дії тарифу. Це потрібно, щоб система могла правильно розрахувати вартість споживання навіть тоді, коли тариф змінювався з часом, і при цьому не втрачалася коректність історичних розрахунків.
     Сутність Consumption_records є основною таблицею подій і містить фактичні записи споживання за датами. Саме тут фіксуються значення спожитих кіловат годин, ціна за кіловат годину, яка була застосована до запису, підсумкова вартість, дата запису та додаткові нотатки. Окреме збереження застосованої ціни у записі дозволяє не перераховувати історію при зміні тарифу, оскільки вартість для конкретного дня вже зафіксована як частина даних.
     Сутність Limits відповідає за обмеження споживання. Вона зберігає встановлені ліміти в кіловат годинах на певний період, а також параметри сповіщення, щоб система могла визначати наближення до порогу та перевищення.
     3.2 Зв’язки між таблицями та правила цілісності
     Зв’язок між Users та Consumption_records має тип один до багатьох, оскільки один користувач може мати багато записів споживання за різні дні. Аналогічно Users пов’язаний з Appliances як один до багатьох, бо користувач може створити декілька приладів у своєму профілі. При цьому зв’язок між Appliances та Consumption_records є опціональним для запису споживання, оскільки поле appliance_id може бути порожнім. Це дозволяє додавати записи загального споживання без прив’язки до конкретного приладу, або коли користувач ще не налаштував перелік приладів.
     Зв’язок між Users та Tariffs також один до багатьох, адже користувач може мати історію тарифів, які діяли в різні періоди. У моделі передбачені поля valid_from та valid_to, що задають часові межі дії тарифу, а також ознака активності, яка допомагає визначати поточний тариф.

     Зв’язок між Users та Limits один до багатьох, бо користувач може створювати кілька лімітів для різних періодів або різних інтервалів часу. Поля period_start та period_end визначають рамки ліміту, а period_type описує тип періоду, наприклад тиждень, місяць, рік або довільний інтервал. Додаткові поля alert_enabled та alert_threshold_percent потрібні для логіки сповіщень, коли система фіксує досягнення відсотка використання та може попередити користувача. Усі ці зв’язки разом формують узгоджену структуру БД, де первинні ключі забезпечують унікальність записів, а зовнішні ключі гарантують цілісність посилань між даними користувача, його приладами, тарифами, записами споживання та лімітами.
    4 Розробка бази даних 
     4.1 Реалізація бази даних у MySQL
     Для програмної системи Energy Tracker було розроблено та реалізовано реляційну базу даних у MySQL. Розгортання виконувалося через XAMPP, а керування схемою та перевірка даних проводилися у phpMyAdmin. Такий підхід дозволяє швидко запускати серверну частину на локальній машині, створювати таблиці, контролювати зв’язки між ними та тестувати запити без додаткових інструментів.
     Структура бази даних побудована навколо користувача, оскільки всі дані системи належать конкретному обліковому запису. Таблиця users зберігає реєстраційні дані та хеш пароля. Таблиця appliances містить перелік електроприладів користувача, які можуть прив’язуватися до записів споживання. Таблиця tariffs зберігає тарифи з періодами дії та ознакою активності, що дозволяє відстежувати історію змін тарифів і застосовувати актуальну ціну під час розрахунків. Таблиця consumption_records є основною для обліку споживання, у ній фіксуються кіловат години, ціна що була застосована під час розрахунку, підсумкова вартість, дата запису та додаткові нотатки. Для контролю планових обмежень споживання використовується таблиця limits, де зберігаються ліміт у кіловат годинах, тип періоду, межі періоду та налаштування попереджень.
     Зв’язки реалізовані зовнішніми ключами. Видалення користувача прибирає всі його залежні дані через каскадне видалення. Для записів споживання прив’язка до приладу є необов’язковою, тому при видаленні приладу поле appliance_id стає порожнім значенням, а сам запис споживання зберігається. Додатково створено індекс за користувачем і датою у таблиці consumption_records, що прискорює формування звітів та вибірок за період.

Рис. 3 – Діаграма структури бази даних

     4.2 SQL скрипт створення таблиць
     Нижче наведено SQL скрипт створення таблиць, який відповідає поточній реалізованій схемі бази даних. Він задає поля, типи даних, первинні ключі, зовнішні ключі, обмеження унікальності для email, часові мітки та індекс для прискорення звітів за датами.
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE appliances (
  id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  name VARCHAR(120) NOT NULL,
  description VARCHAR(500),
  estimated_power DECIMAL(10,3),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE tariffs (
  id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  price_per_kwh DECIMAL(10,4) NOT NULL,
  tariff_name VARCHAR(120) NOT NULL,
  valid_from DATE NOT NULL,
  valid_to DATE,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE consumption_records (
  id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  appliance_id INT NULL,
  consumption_kwh DECIMAL(10,3) NOT NULL,
  applied_price_per_kwh DECIMAL(10,4) NOT NULL,
  cost DECIMAL(12,4) NOT NULL,
  record_date DATE NOT NULL,
  notes VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (appliance_id) REFERENCES appliances(id) ON DELETE SET NULL,
  INDEX idx_user_date (user_id, record_date)
);

CREATE TABLE limits (
  id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  limit_kwh DECIMAL(10,3) NOT NULL,
  period_type ENUM('week','month','year','custom') NOT NULL,
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  alert_enabled BOOLEAN DEFAULT TRUE,
  alert_threshold_percent INT DEFAULT 80,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
    5 Функції роботи з бд 
     5.1 Підхід до доступу до даних через ORM
     Для роботи з базою даних у серверній частині застосовано ORM підхід на основі Sequelize. Це означає, що таблиці MySQL представлені як програмні моделі, а читання та зміна даних виконуються через методи цих моделей. У результаті логіка доступу до даних не прив’язується до ручного написання SQL у кожному місці коду, а зосереджується у єдиному стилі викликів, який однаково зрозумілий для всіх сутностей системи. Такий підхід також зменшує ризик помилок у запитах, спрощує підтримку зв’язків між таблицями та робить код більш стабільним під час розширення функціоналу.
     У межах реалізації описано моделі Users, Appliances, Tariffs, ConsumptionRecords та Limits. Для кожної з них визначено поля та типи, а також зв’язки між сутностями. Наприклад, прилади та тарифи належать конкретному користувачу, записи споживання можуть бути прив’язані до приладу або залишатися без прив’язки, якщо дані внесено загальним підсумком. Ліміти також належать користувачу та задають контрольний період, який використовується під час побудови звітів і перевірки прогресу.
     5.2 Реалізовані операції з даними та підтримка звітів
     На рівні функцій роботи з БД реалізовано стандартні операції створення, отримання, оновлення та видалення записів. У практичній частині це проявляється у можливості керувати списком приладів, тарифами, записами споживання та лімітами. Для збереження коректності даних використовується валідація дат у певному форматі, перевірка допустимих значень, а також контроль періодів лімітів, щоб вони не перетиналися для одного типу періоду в межах одного користувача.
     Окремо реалізовано функції агрегації, які потрібні для звітності. Для підсумкових і добових звітів використовуються агрегатні обчислення сум споживання та вартості, кількості записів та групування за датою. Для звіту розподілу за приладами використовується групування за appliance_id з додатковим підвантаженням назв приладів, щоб результат був зрозумілим для користувача. Для звіту по лімітах реалізовано підрахунок використання в межах періодів лімітів, визначення відсотка використання та статусу, а також формування підсумкових показників за всіма знайденими лімітами.
     Швидкість роботи звітів підтримується індексом idx_user_date у таблиці consumption_records. Він створений за двома полями user_id та record_date й прискорює вибірки, коли система формує звіти за період і відбирає записи конкретного користувача в межах заданих дат. Це напряму відповідає сценаріям, де найчастіше робляться запити на зразок отримати всі записи користувача за проміжок часу та порахувати сумарні значення.
    6 Специфікація API для взаємодії серверної частини з клієнтами
     У межах програмної системи для контролю енергоспоживання серверна частина надає HTTP API, який використовується клієнтським застосунком для реєстрації та входу користувача, керування довідниками електроприладів і тарифів, внесення записів споживання, встановлення лімітів, а також формування зведених звітів і експорту результатів. API побудовано у стилі REST та реалізовано на Node.js із використанням Express.js. Для перевірки доступу застосовано JWT автентифікацію, тому частина ендпоінтів доступна лише після входу в систему та передачі токена в заголовку Authorization у форматі Bearer token. Специфікація API підтримується через Swagger і відображається у вигляді груп ендпоінтів за функціональними модулями.


Рис. 4 – Ендпоінти у Swagger UI

      6.1 Модуль автентифікації та ідентифікації користувача
     Модуль Auth забезпечує створення облікового запису, отримання JWT токена для подальших запитів, а також перевірку поточного користувача за вже виданим токеном. Реєстрація і вхід працюють без попередньої авторизації, а запит інформації про поточного користувача працює лише з валідним токеном.
     6.1.1 Реєстрація користувача
     Ендпоінт призначений для створення нового користувача в системі. На рівні валідації перевіряється наявність email і password, а також унікальність email. Пароль не зберігається у відкритому вигляді, замість цього у базі даних формується password_hash за допомогою bcryptjs.
Метод і шлях: POST /api/auth/register
Авторизація: не потрібна.
Тіло запиту у форматі application/json:
- email як рядок,
- password як рядок.
Очікувані відповіді:
- 201, якщо користувача створено, у відповіді повертається id та email,
- 400, якщо дані не передані або email уже існує (помилка).
Приклад запиту:
{
  "email": "test3@mail.com",
  "password": "password123"
}
Приклад відповіді 201:
{
  "id": 3,
  "email": "test3@mail.com"
}
     6.1.2 Вхід у систему та отримання JWT
     Ендпоінт виконує перевірку облікових даних користувача. Сервер знаходить користувача за email, порівнює пароль із password_hash через bcryptjs і у разі успіху видає JWT токен з терміном дії 7 днів. Цей токен використовується для доступу до захищених ендпоінтів інших модулів.
     Метод і шлях: POST /api/auth/login
     Авторизація: не потрібна.
Тіло запиту у форматі application/json:
- email як рядок,
- password як рядок.
Очікувані відповіді:
- 200, якщо облікові дані коректні, повертається token,
- 401, якщо email не знайдено або пароль неправильний.
Приклад запиту:
{
  "email": "test3@mail.com",
  "password": "password123"
}
Приклад відповіді 201:
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjMsImlhdCI6MTc2NjYzMzc0NCwiZXhwIjoxNzY3MjM4NTQ0fQ.FDrUB85eE6TUuR9pSWmIQSNIWyHdrsFGbk4yrXibfac"
}
     6.1.3 Отримання поточного користувача за токеном
     Ендпоінт використовується для перевірки, що токен валідний, а також для отримання ідентифікатора поточного користувача. Це зручно для клієнта після перезавантаження сторінки, коли потрібно швидко переконатися, що сесія активна, і зрозуміти, з яким користувачем працює застосунок.
     Метод і шлях: GET /api/auth/me
     Авторизація: потрібна, використовується Bearer токен у заголовку Authorization.
Тіло запиту – не використовується.
Очікувані відповіді:
- 200, якщо токен коректний, повертається id користувача,
- 401, якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/auth/me
Authorization: Bearer <token>
Приклад відповіді 200:
{
  "id": 3
}
     6.2 Модуль Appliances
     Модуль Appliances відповідає за довідник електроприладів користувача. Ці записи потрібні для того, щоб прив’язувати споживання до конкретного приладу, будувати розподіл у звітах і зберігати додаткову інформацію про техніку, наприклад назву, опис і орієнтовну потужність. Усі ендпоінти цього модуля працюють тільки для авторизованого користувача, тому в кожному запиті потрібен Bearer токен.
     6.2.1 Отримання списку електроприладів
     Ендпоінт повертає перелік усіх приладів, створених поточним користувачем. Сортування виконується за спаданням id, тому найновіші записи будуть на початку списку. Повертаються поля приладу у тому вигляді, як вони збережені в базі даних.
Метод і шлях: GET /api/appliances
Авторизація: потрібна, Bearer токен у заголовку Authorization.
Тіло запиту – не використовується.
Очікувані відповіді:
- 200, якщо токен валідний, повертається масив приладів,
- 401, якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/appliances
Authorization: Bearer <token>
Приклад відповіді 200:
[
  {
    "id": 1,
    "user_id": 2,
    "name": "updated iron",
    "description": "iron for clothes",
    "estimated_power": "2.200",
    "created_at": "2025-12-24T19:59:28.000Z"
  }
]
     6.2.2 Створення електроприладу
     Ендпоінт створює новий прилад для поточного користувача. Мінімально необхідним є поле name. Поля description та estimated_power є необов’язковими, і якщо вони не передані, то зберігаються як null. На рівні валідації перевіряється лише наявність name.
Метод і шлях: POST /api/appliances
Авторизація: потрібна.
Тіло запиту:
- name як рядок,
- description як рядок, необов’язково,
- estimated_power як число, необов’язково.
Очікувані відповіді:
- 201, якщо прилад створено, повертається створений об’єкт,
- 400, якщо name не передано,
- 401, якщо токен відсутній або недійсний.
Приклад запиту:
{
  "name": "Boiler",
  "description": "Bathroom boiler",
  "estimated_power": 2
}
Приклад відповіді 200:
{
  "created_at": "2025-12-25T03:54:06.529Z",
  "id": 3,
  "user_id": 2,
  "name": "Boiler",
  "description": "Bathroom boiler",
  "estimated_power": 2
}
     6.2.3 Оновлення електроприладу
     Ендпоінт дозволяє змінити будь-які поля приладу. Оновлюється тільки той прилад, який належить поточному користувачу. Якщо запис з таким id не знайдено або він належить іншому користувачу, повертається помилка not found. Якщо певні поля не передані, вони залишаються без змін.
Метод і шлях: PATCH /api/appliances/{id}
Авторизація: потрібна.
Тіло запиту:
- id як ціле число,
- Тіло запиту у форматі application/json,
- name як рядок, необов’язково,
- description як рядок, необов’язково,
- estimated_power як число, необов’язково.
Очікувані відповіді:
- 200, якщо прилад оновлено, повертається оновлений об’єкт,
- 404, якщо прилад не знайдено для поточного користувача,
- 401, якщо токен відсутній або недійсний.
Приклад запиту:
PATCH /api/appliances/5
Authorization: Bearer <token>
Content-Type: application/json

{
  "description": "Boiler in bathroom",
  "estimated_power": 2.2
}
Приклад відповіді 200:
{
  "id": 3,
  "user_id": 2,
  "name": "Boiler",
  "description": "Boiler in bathroom",
  "estimated_power": 2.2,
  "created_at": "2025-12-25T03:54:06.000Z"
}
     6.2.4 Видалення електроприладу
     Ендпоінт видаляє прилад поточного користувача за його id. Якщо прилад не знайдено, повертається помилка not found. При успішному видаленні сервер повертає порожню відповідь зі статусом 204.
Метод і шлях: DELETE /api/appliances/{id}
Авторизація: потрібна.
Тіло запиту:
- id як ціле число.
Очікувані відповіді:
- 204, якщо прилад видалено,
- 404, якщо прилад не знайдено для поточного користувача,
- 401, якщо токен відсутній або недійсний.
Приклад запиту:
DELETE /api/appliances/3
Authorization: Bearer <token>
Приклад відповіді 204:
       тіло відповіді відсутнє
     6.3 Модуль обліку споживання електроенергії
     Модуль Consumption відповідає за збереження щоденних записів споживання у кВт*год, прив’язку запису до конкретного приладу, а також автоматичний розрахунок вартості на основі активного тарифу. Усі ендпоінти цього модуля працюють лише для авторизованого користувача, тому кожен запит вимагає Bearer токен у заголовку Authorization. Додатково модуль перевіряє коректність дат у форматі yyyy-mm-dd, не дозволяє одночасно передавати consumption_kwh і usage_hours, а також контролює, щоб у користувача був рівно один активний тариф.
     6.3.1 Отримання списку записів споживання
     Ендпоінт повертає всі записи споживання поточного користувача. Дозволено додатково обмежити вибірку за періодом, передаючи параметри date_from і date_to. Якщо переданий лише один з параметрів, система сприймає це як фільтр «від дати» або «до дати». Якщо передані обидва, застосовується фільтр між двома датами включно.
Метод і шлях: GET /api/consumption
Авторизація: потрібна.
Тіло запиту:
- date_from як рядок у форматі yyyy-mm-dd, необов’язково,
- date_to як рядок у форматі yyyy-mm-dd, необов’язково.
Очікувані відповіді:
- 200, якщо запит виконано успішно,
- 400, якщо date_from або date_to мають неправильний формат або date_from пізніше за date_to.
Приклад запиту:
GET /api/consumption?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад відповіді 200:
[
  {
    "id": 2,
    "user_id": 2,
    "appliance_id": 1,
    "consumption_kwh": "5.300",
    "applied_price_per_kwh": "12.0000",
    "cost": "63.6000",
    "record_date": "2025-12-25",
    "notes": "string",
    "created_at": "2025-12-24T22:12:07.000Z",
    "updated_at": "2025-12-24T22:28:08.000Z"
  },
  {
    "id": 3,
    "user_id": 2,
    "appliance_id": null,
    "consumption_kwh": "3.500",
    "applied_price_per_kwh": "6.0000",
    "cost": "21.0000",
    "record_date": "2025-12-24",
    "notes": "Evening usage",
    "created_at": "2025-12-24T22:12:38.000Z",
    "updated_at": "2025-12-24T23:09:52.000Z"
  },
  {
    "id": 1,
    "user_id": 2,
    "appliance_id": 1,
    "consumption_kwh": "4.400",
    "applied_price_per_kwh": "6.0000",
    "cost": "26.4000",
    "record_date": "2025-12-24",
    "notes": "Evening usage",
    "created_at": "2025-12-24T22:11:26.000Z",
    "updated_at": "2025-12-24T22:11:26.000Z"
  }
]
     6.3.2 Додавання запису споживання з автоматичним розрахунком вартості
     Ендпоінт створює новий запис споживання для поточного користувача. Обов’язково потрібно передати record_date. Значення споживання можна задати двома способами. Перший спосіб це передати consumption_kwh напряму. Другий спосіб це передати usage_hours, тоді система обчислить кВт*год автоматично за формулою estimated_power помножити на usage_hours, але для цього обов’язково потрібен appliance_id і у відповідного приладу має бути заповнене estimated_power більше нуля. Одночасно передавати consumption_kwh і usage_hours заборонено.
     Перед створенням запису система шукає активний тариф користувача. Якщо активного тарифу немає, створення блокується. Якщо активних тарифів більше одного, створення також блокується, і у відповіді повертається список ідентифікаторів активних тарифів.
     Після цього система бере ціну price_per_kwh з активного тарифу, записує її як applied_price_per_kwh, а також рахує cost і зберігає його у таблиці consumption_records.
Метод і шлях: POST /api/consumption
Авторизація: потрібна.
Тіло запиту:
- record_date як рядок yyyy-mm-dd,
- appliance_id як число, необов’язково,
- consumption_kwh як число, необов’язково,
- usage_hours як число, необов’язково,
- notes як рядок, необов’язково.
Очікувані відповіді:
- 201, якщо запис створено, повертається створений запис,
- 400, якщо record_date не передано або формат неправильний,
- 400, якщо не передано ні consumption_kwh ні usage_hours,
- 400, якщо передано і consumption_kwh і usage_hours одночасно,
- 400, якщо usage_hours передано без appliance_id,
- 400, якщо usage_hours передано, але у приладу estimated_power не заданий або невалідний,
- 400, якщо у користувача немає активного тарифу,
- 404, якщо appliance_id вказаний, але прилад не знайдено або він належить іншому користувачу,
- 409, якщо знайдено більше одного активного тарифу.
Приклад запиту:
{
  "appliance_id": 1,
  "consumption_kwh": 3.5,
  "record_date": "2025-12-14",
  "notes": "Evening usage"
}
Приклад відповіді 201:
{
  "created_at": "2025-12-25T04:13:03.995Z",
  "updated_at": "2025-12-25T04:13:03.995Z",
  "id": 6,
  "user_id": 2,
  "appliance_id": 1,
  "consumption_kwh": "3.500",
  "applied_price_per_kwh": "6.0000",
  "cost": "21.0000",
  "record_date": "2025-12-14",
  "notes": "Evening usage"
}
     6.3.3 Оновлення запису споживання з перерахунком вартості
     Ендпоінт дозволяє змінювати існуючий запис споживання, який належить поточному користувачу. Після будь-якої зміни значення споживання або дати система повторно розраховує cost, використовуючи поточний активний тариф. Це означає, що зміна запису може змінити applied_price_per_kwh і cost навіть тоді, коли користувач не передавав ціну напряму. Так само, як і при створенні, одночасне передавання consumption_kwh і usage_hours заборонено. При зміні appliance_id дозволено передати null, щоб прибрати прив’язку до приладу.
     Як і в POST, перед оновленням виконується жорстка перевірка активного тарифу. За відсутності активного або за наявності кількох активних тарифів оновлення блокується. Після цього система бере ціну price_per_kwh з активного тарифу, записує її як applied_price_per_kwh, а також рахує cost і зберігає його у таблиці consumption_records.
Метод і шлях: PATCH /api/consumption/{id}
Авторизація: потрібна.
Тіло запиту:
- appliance_id як число або null,
- consumption_kwh як число,
- usage_hours як число,
- record_date як рядок yyyy-mm-dd,
- notes як рядок.
Очікувані відповіді:
- 200, якщо запис оновлено, повертається оновлений запис,
- 400, якщо формат record_date неправильний,
- 400, якщо одночасно передано consumption_kwh і usage_hours,
- 400, якщо usage_hours передано без доступного appliance і без валідного estimated_power,
- 404, якщо запис не знайдено або він не належить поточному користувачу,
- 409, якщо знайдено більше одного активного тарифу.
Приклад запиту:
PATCH /api/consumption/6
Authorization: Bearer <token>
Content-Type: application/json

{
  "consumption_kwh": 4.2,
  "notes": "Updated value"
}
Приклад відповіді 200:
{
  "id": 6,
  "user_id": 2,
  "appliance_id": 1,
  "consumption_kwh": "4.200",
  "applied_price_per_kwh": "6.0000",
  "cost": "25.2000",
  "record_date": "2025-12-14",
  "notes": "Updated value",
  "created_at": "2025-12-25T04:13:03.000Z",
  "updated_at": "2025-12-25T04:13:03.000Z"
}
     6.3.4 Видалення запису споживання
     Ендпоінт видаляє запис consumption_records за його id, але лише якщо він належить поточному користувачу. У разі успіху сервер повертає порожню відповідь зі статусом 204.
Метод і шлях: DELETE /api/consumption/{id}
Авторизація: потрібна.
Тіло запиту:
- id як число.
Очікувані відповіді:
- 204, якщо запис видалено,
- 404, якщо запис не знайдено або він не належить поточному користувачу.
Приклад запиту:
DELETE /api/consumption/6
Authorization: Bearer <token>
Приклад відповіді 204:
       тіло відповіді відсутнє
     6.4 Модуль лімітів енергоспоживання
     Модуль Limits відповідає за збереження та керування лімітами споживання для користувача на певний період. Ліміт задає верхню межу кіловат годин, а також правила сповіщення, коли користувач підходить до заданого порога або перевищує ліміт. Період ліміту задається типом week, month, year або custom. Для week, month та year система очікує тільки дату початку періоду, а дату завершення рахує автоматично на основі додавання відповідного інтервалу до початку. Для custom користувач задає і дату початку, і дату кінця вручну. Додатково модуль не дозволяє створювати два ліміти одного і того самого типу, які перетинаються по датах, щоб уникнути конфліктів у розрахунках прогресу.
     6.4.1 Отримання списку лімітів користувача
     Ендпоінт повертає всі ліміти поточного користувача. Доступні необовʼязкові фільтри за типом періоду та за конкретною датою, щоб швидко знайти ліміти, які покривають вибраний день.
Метод і шлях: GET /api/limits
Авторизація: потрібна.
Тіло запиту:
- period_type як рядок, допустимі значення week, month, year, custom,
- date як рядок у форматі yyyy-mm-dd, при вказанні повертаються лише ліміти, в яких date потрапляє між period_start і period_end включно.
Очікувані відповіді:
- 200 повертається масив лімітів,
- 400 якщо period_type некоректний або date має неправильний формат.
Приклад запиту:
       GET /api/limits?period_type=month
   Authorization: Bearer <token>
Приклад відповіді 200:
[
  {
    "id": 5,
    "user_id": 2,
    "limit_kwh": "150.000",
    "period_type": "month",
    "period_start": "2025-12-11",
    "period_end": "2026-01-10",
    "alert_enabled": true,
    "alert_threshold_percent": 80,
    "created_at": "2025-12-25T01:43:50.000Z"
  }
]
     6.4.2 Створення нового ліміту
     Ендпоінт створює новий ліміт для поточного користувача. Перевіряється коректність типу періоду, валідність дати початку, валідність числового значення limit_kwh і параметрів сповіщень. Для типів week, month та year дата завершення має бути або відсутня в запиті, або збігатися з автоматично розрахованою системою. Для custom дата завершення є обовʼязковою. Також перевіряється відсутність перетину з уже існуючим лімітом цього самого типу.
Метод і шлях: POST /api/limits
Авторизація: потрібна.
Тіло запиту:
- limit_kwh як число, має бути додатним,
- period_type як рядок, week або month або year або custom,
- period_start як рядок yyyy-mm-dd,
- period_end як рядок yyyy-mm-dd, потрібний лише для custom,
- alert_enabled як boolean, якщо не передати, береться true,
- alert_threshold_percent як ціле 1..100, якщо не передати, береться 80.
Очікувані відповіді:
- 201 якщо створено, повертається створений запис ліміту,
- 400 якщо дані невалідні або period_end не відповідає автоперіоду,
- 409 якщо вже існує ліміт такого самого period_type, який перетинається по датах, у відповіді буде existing_limit_id.
Приклад запиту:
{
  "limit_kwh": 150,
  "period_type": "custom",
  "period_start": "2026-12-11",
  "period_end": "2027-06-20",
  "alert_enabled": true,
  "alert_threshold_percent": 80
}
Приклад відповіді 201:
{
  "created_at": "2025-12-25T04:32:17.421Z",
  "id": 8,
  "user_id": 2,
  "limit_kwh": "150.000",
  "period_type": "custom",
  "period_start": "2026-12-11",
  "period_end": "2027-06-20",
  "alert_enabled": true,
  "alert_threshold_percent": 80
}
     6.4.3 Оновлення існуючого ліміту
     Ендпоінт дозволяє змінити параметри ліміту. Перед оновленням перевіряється, що ліміт належить поточному користувачу. Далі застосовуються ті самі правила валідації, що і при створенні. Якщо змінюється period_type або period_start, то period_end для не custom типів має відповідати автоматично очікуваному значенню. Для custom типу period_end має бути валідною датою і не раніше start. Також знову перевіряється, щоб ліміт після змін не почав перетинатися з іншим лімітом такого самого типу.
Метод і шлях: PATCH /api/limits/{id}
Авторизація: потрібна.
У тіло запиту можна передавати будь які поля з:
limit_kwh, period_type, period_start, period_end, alert_enabled, alert_threshold_percent.
Очікувані відповіді:
- 200 якщо оновлено, повертається оновлений запис,
- 400 якщо дані невалідні або period_end не відповідає автоперіоду,
- 404 якщо ліміт не знайдено або він не належить користувачу,
- 409 якщо після оновлення зʼявився перетин з іншим лімітом цього самого типу.
Приклад запиту:
PATCH /api/consumption/8
Authorization: Bearer <token>
Content-Type: application/json

{
  "limit_kwh": 200,
  "period_type": "custom",
  "period_start": "2027-12-22",
  "period_end": "2028-06-13",
  "alert_enabled": false,
  "alert_threshold_percent": 70
       }
Приклад відповіді 200:
{
  "id": 8,
  "user_id": 2,
  "limit_kwh": "200.000",
  "period_type": "custom",
  "period_start": "2027-12-22",
  "period_end": "2028-06-13",
  "alert_enabled": false,
  "alert_threshold_percent": 70,
  "created_at": "2025-12-25T04:32:17.000Z"
}
     6.4.4 Видалення ліміту
     Ендпоінт видаляє ліміт поточного користувача за id.
Метод і шлях: DELETE /api/limits/{id}
Авторизація: потрібна.
У тіло запиту можна передавати будь які поля з:
limit_kwh, period_type, period_start, period_end, alert_enabled, alert_threshold_percent.
Очікувані відповіді:
- 204 якщо видалено,
- 404 якщо не знайдено.
Приклад запиту:
DELETE /api/limits/6
Authorization: Bearer <token>
Приклад відповіді 204:
       тіло відповіді відсутнє
     6.4.5 Отримання прогресу по ліміту
     Ендпоінт рахує, скільки кіловат годин вже використано за період ліміту, який відсоток від limit_kwh це становить, і чи спрацював поріг сповіщення або перевищення. Розрахунок виконується як сума consumption_kwh з таблиці consumption_records у межах period_start та period_end.
Метод і шлях: GET /api/limits/{id}/progress
Авторизація: потрібна.
У тіло запиту можна передавати будь які поля з:
limit_kwh, period_type, period_start, period_end, alert_enabled, alert_threshold_percent.
Очікувані відповіді:
- 200 повертається обʼєкт прогресу, включно з used_kwh, percent_used, threshold_reached, limit_exceeded,
- 404 якщо ліміт не знайдено.
Приклад запиту:
   GET /api/limits/6/progress
   Authorization: Bearer <token>
Приклад відповіді 200:
{
  "limit_id": 6,
  "period_type": "year",
  "period_start": "2025-12-11",
  "period_end": "2026-12-10",
  "limit_kwh": "1500.000",
  "used_kwh": "13.200",
  "percent_used": 0.88,
  "alert_enabled": true,
  "alert_threshold_percent": 80,
  "threshold_reached": false,
  "limit_exceeded": false
}
     6.5 Модуль формування звітів
     Модуль Reports призначений для отримання агрегованої статистики зі споживання електроенергії за обраний період. Усі ендпоінти модуля працюють лише для авторизованого користувача, а дані вибираються з consumption_records із привязкою до поточного user_id. Період у більшості звітів задається двома датами date_from та date_to у форматі yyyy-mm-dd. Якщо параметри періоду передані некоректно, сервер повертає помилку валідації.
     6.5.1 Підсумковий звіт за період
     Ендпоінт повертає загальні підсумки за період, середні значення та день з найбільшим споживанням. На основі записів consumption_records обчислюється сума кіловат годин, сумарна вартість, кількість записів, середні показники на день і на запис, а також визначається дата з максимальним day_kwh.
Метод і шлях: GET /api/reports/summary
Авторизація: потрібна.
Тіло запиту:
- date_from обовязковий параметр у форматі yyyy-mm-dd,
- date_to обовязковий параметр у форматі yyyy-mm-dd.
Очікувані відповіді:
- 200 якщо звіт сформовано,
- 400 якщо date_from або date_to відсутні або мають некоректний формат або date_from пізніше за date_to,
- 401 якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/reports/summary?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад відповіді 200:
{
  "period": {
    "date_from": "2025-12-01",
    "date_to": "2025-12-31",
    "days": 31
  },
  "totals": {
    "total_kwh": 13.2,
    "total_cost": 111,
    "records_count": 3
  },
  "averages": {
    "kwh_per_day": 0.4258,
    "cost_per_day": 3.5806,
    "kwh_per_record": 4.4,
    "cost_per_record": 37
  },
  "max_day": {
    "date": "2025-12-24",
    "kwh": 7.9,
    "cost": 47.4
  }
}
     6.5.2 Денний звіт за період
     Ендпоінт повертає список днів у межах періоду з групуванням записів за record_date. Для кожного дня підраховуються total_kwh, total_cost і records_count. Такий звіт зручний як джерело даних для графіків динаміки за датами.
Метод і шлях: GET /api/reports/daily
Авторизація: потрібна.
Тіло запиту:
- date_from обовязковий параметр у форматі yyyy-mm-dd,
- date_to обовязковий параметр у форматі yyyy-mm-dd.
Очікувані відповіді:
- 200 якщо звіт сформовано,
- 400 якщо date_from або date_to відсутні або мають некоректний формат або date_from пізніше за date_to,
- 401 якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/reports/daily?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад відповіді 200:
[
  {
    "record_date": "2025-12-24",
    "total_kwh": 7.9,
    "total_cost": 47.4,
    "records_count": 2
  },
  {
    "record_date": "2025-12-25",
    "total_kwh": 5.3,
    "total_cost": 63.6,
    "records_count": 1
  }
]
     6.5.3 Розподіл споживання за приладами
     Ендпоінт формує розподіл витрат та споживання по приладах. Записи групуються за appliance_id, підраховуються total_kwh, total_cost і records_count. Додатково, якщо appliance_id не порожній, сервер підтягує назву приладу з таблиці appliances та повертає appliance_name. Записи з appliance_id рівним null також можуть зявитися, якщо частина споживання була внесена без привязки до конкретного приладу.
Метод і шлях: GET /api/reports/by-appliance
Авторизація: потрібна.
Тіло запиту:
- date_from обовязковий параметр у форматі yyyy-mm-dd,
- date_to обовязковий параметр у форматі yyyy-mm-dd.
Очікувані відповіді:
- 200 якщо звіт сформовано,
- 400 якщо date_from або date_to відсутні або мають некоректний формат або date_from пізніше за date_to,
- 401 якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/reports/by-appliance?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад відповіді 200:
[
  {
    "appliance_id": 1,
    "appliance_name": "updated iron",
    "total_kwh": 9.7,
    "total_cost": 90,
    "records_count": 2
  },
  {
    "appliance_id": null,
    "appliance_name": null,
    "total_kwh": 3.5,
    "total_cost": 21,
    "records_count": 1
  }
       ]
     6.5.4 Звіт по лімітах
     Ендпоінт повертає перелік лімітів користувача з розрахованим прогресом використання та підсумковою статистикою. Дані формуються на основі limits і сумування consumption_records у межах period_start та period_end кожного ліміту. Підтримуються фільтри за типом періоду, списком id та статусом. Додатково можна передати date_from і date_to, тоді вибираються лише ті ліміти, періоди яких перетинаються з вказаним проміжком.
Метод і шлях: GET /api/reports/limits
Авторизація: потрібна.

Тіло запиту:
- period_type необовязковий параметр, список через кому week, month, year, custom,
- ids необовязковий параметр, список id через кому,
- status необовязковий параметр, список через кому ok, threshold_reached, limit_exceeded,
- date_from необовязковий параметр у форматі yyyy-mm-dd, використовується лише разом з date_to,
- date_to необовязковий параметр у форматі yyyy-mm-dd, використовується лише разом з date_from.
Очікувані відповіді:
- 200 якщо звіт сформовано,
- 400 якщо period_type або ids або status мають некоректний формат, або date_from передано без date_to, або date_from пізніше за date_to,
- 401 якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/reports/limits?period_type=month,year
Authorization: Bearer <token>
Приклад відповіді 200:
{
  "filters": {
    "period_type": [
      "month",
      "year"
    ],
    "ids": null,
    "status": null,
    "period": null
  },
  "totals": {
    "limits_count": 2,
    "ok_count": 2,
    "threshold_reached_count": 0,
    "limit_exceeded_count": 0,
    "total_limit_kwh": 1650,
    "total_used_kwh": 26.4
  },
  "items": [
    {
      "id": 6,
      "period_type": "year",
      "period_start": "2025-12-11",
      "period_end": "2026-12-10",
      "limit_kwh": 1500,
      "used_kwh": 13.2,
      "remaining_kwh": 1486.8,
      "percent_used": 0.88,
      "alert_enabled": true,
      "alert_threshold_percent": 80,
      "threshold_reached": false,
      "limit_exceeded": false,
      "status": "ok"
    },
    {
      "id": 5,
      "period_type": "month",
      "period_start": "2025-12-11",
      "period_end": "2026-01-10",
      "limit_kwh": 150,
      "used_kwh": 13.2,
      "remaining_kwh": 136.8,
      "percent_used": 8.8,
      "alert_enabled": true,
      "alert_threshold_percent": 80,
      "threshold_reached": false,
      "limit_exceeded": false,
      "status": "ok"
    }
  ]
}
     6.6 Експорт звітів у CSV
     Для зручного перенесення даних у табличні редактори реалізовано окремий набір ендпоінтів експорту. Вони повертають файл у форматі CSV. У відповідь віддається текст у кодуванні UTF 8 з BOM, а також службовий рядок sep=; на початку файлу, щоб Excel коректно визначив розділювач. Як розділювач використовується крапка з комою. Ендпоінти експорту працюють з тією ж логікою фільтрації періоду, що і звичайні звіти, тому для більшості випадків достатньо вказати date_from та date_to.
     6.6.1 Експорт підсумкового звіту
     Ендпоінт формує файл з підсумками за період. У файлі будуть загальні значення споживання та вартості, кількість записів, середні значення, а також день з максимальним споживанням і його параметри.
Метод і шлях: GET /api/reports/export/summary.csv
Авторизація: потрібна.
Тіло запиту:
- date_from обовʼязково у форматі yyyy-mm-dd,
- date_to обовʼязково у форматі yyyy-mm-dd.
Очікувані відповіді:
- 200 якщо файл сформовано,
- 400 якщо період не передано або формат дат неправильний.
Приклад запиту:
GET /api/reports/export/summary.csv?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад отриманого файлу при відповіді 200:

     
     
     6.6.2 Експорт щоденного звіту
     Ендпоінт формує CSV, у якому дані згруповані по днях. Для кожної дати з періоду виводиться сумарне споживання, сумарна вартість та кількість записів.
Метод і шлях: GET /api/reports/export/daily.csv
Авторизація: потрібна.
Тіло запиту:
- date_from обовʼязково у форматі yyyy-mm-dd,
- date_to обовʼязково у форматі yyyy-mm-dd.
Очікувані відповіді:
- 200 якщо файл сформовано,
- 400 якщо період не передано або формат дат неправильний.
Приклад запиту:
GET /api/reports/export/daily.csv?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад отриманого файлу при відповіді 200:

     6.6.3 Експорт розподілу за приладами
     Ендпоінт формує CSV, у якому дані згруповані за appliance_id. У результаті видно, який прилад дав найбільший внесок у споживання і у вартість. Для зручності додається appliance_name, якщо запис привʼязаний до конкретного приладу.
Метод і шлях: GET /api/reports/export/by-appliance.csv
Авторизація: потрібна.
Тіло запиту:
- date_from обовʼязково у форматі yyyy-mm-dd,
- date_to обовʼязково у форматі yyyy-mm-dd.
Очікувані відповіді:
- 200 якщо файл сформовано,
- 400 якщо період не передано або формат дат неправильний.
Приклад запиту:
GET /api/reports/export/by-appliance.csv?date_from=2025-12-01&date_to=2025-12-31
Authorization: Bearer <token>
Приклад отриманого файлу при відповіді 200:

Строка без appliance_name – це сума споживань що не прив’язані до прибору.
     6.6.4 Експорт звіту по лімітах
     Ендпоінт формує CSV по всіх лімітах користувача з розрахунком використаного kWh за кожен ліміт. Додатково повертається статус, який показує нормальний стан, досягнення порогу попередження або перевищення ліміту. Під кінець файла додається службовий рядок TOTAL з агрегованими підсумками по вибірці.
Метод і шлях: GET /api/reports/export/limits.csv
Авторизація: потрібна.
Тіло запиту:
- period_type необовʼязково, комами можна перелічити week, month, year, custom,
- ids необовʼязково, комами перелічити ідентифікатори лімітів,
- status необовʼязково, комами перелічити ok, threshold_reached, limit_exceeded,
- date_from необовʼязково, але лише разом з date_to,
- date_to необовʼязково, але лише разом з date_from.
При використанні date_from та date_to вибираються ліміти, періоди яких перетинаються з заданим відрізком дат
Очікувані відповіді:
- 200 якщо файл сформовано,
- 400 якщо значення фільтрів невалідні.
Приклад запиту:
GET /api/reports/export/limits.csv
Authorization: Bearer <token>
Приклад отриманого файлу при відповіді 200:

     6.7 Модуль керування тарифами
     Модуль Tariffs відповідає за збереження тарифів користувача, підтримку періоду дії тарифу, а також за вибір активного тарифу, який використовується при розрахунку вартості у записах споживання. У системі передбачено, що активним має бути лише один тариф для користувача. При створенні або активації тарифу сервер автоматично деактивує інші тарифи цього користувача. Додатково перевіряється, чи може тариф бути активним саме зараз, тобто чи поточна дата входить у діапазон дії valid_from і valid_to, якщо кінцева дата задана.
     6.7.1 Отримання списку тарифів користувача
     Ендпоінт повертає всі тарифи поточного користувача, включно з неактивними. Дані використовуються для відображення історії тарифів і вибору потрібного тарифу для редагування або активації.
Метод і шлях: GET /api/tariffs
Авторизація: потрібна.
Тіло запиту – не використовується.
Очікувані відповіді:
- 200, якщо токен валідний, повертається масив приладів,
- 401, якщо токен відсутній або недійсний.
Приклад запиту:
GET /api/tariffs
Authorization: Bearer <token>
Приклад відповіді 200:
[
  {
    "id": 5,
    "user_id": 2,
    "price_per_kwh": "6.0000",
    "tariff_name": "Day tariff",
    "valid_from": "2025-01-01",
    "valid_to": "2025-12-31",
    "is_active": true,
    "created_at": "2025-12-24T20:44:33.000Z"
  },
  {
    "id": 4,
    "user_id": 2,
    "price_per_kwh": "4.3200",
    "tariff_name": "Day tariff",
    "valid_from": "2025-01-01",
    "valid_to": "2025-12-31",
    "is_active": false,
    "created_at": "2025-12-24T20:08:48.000Z"
  },
  {
    "id": 2,
    "user_id": 2,
    "price_per_kwh": "12.0000",
    "tariff_name": "updated tariff",
    "valid_from": "2024-12-12",
    "valid_to": "2022-12-12",
    "is_active": false,
    "created_at": "2025-12-24T20:08:44.000Z"
  },
]
     6.7.2 Створення тарифу
     Ендпоінт створює новий тариф для користувача. Обов’язково передаються tariff_name, price_per_kwh і valid_from. Поле valid_to є необов’язковим. Поле is_active визначає, чи буде тариф активним одразу після створення. У поточній реалізації тариф за замовчуванням створюється активним, якщо is_active не передано або якщо is_active не дорівнює false. Якщо створюваний тариф має стати активним, додатково виконується перевірка, що поточна дата входить у період дії цього тарифу. Після цього всі інші тарифи користувача автоматично переводяться в неактивний стан.
Метод і шлях: POST /api/tariffs
Авторизація: потрібна.
Тіло запиту:
- tariff_name як рядок,
- price_per_kwh як число,
- valid_from як дата yyyy-mm-dd,
- valid_to як дата yyyy-mm-dd, необов’язково,
- is_active як boolean, необов’язково.
Очікувані відповіді:
- 201, якщо тариф створено,
- 400, якщо не передані обов’язкові поля або valid_from пізніше за valid_to або тариф не може бути активним на поточну дату.
Приклад запиту:
{
  "tariff_name": "Day tariff",
  "price_per_kwh": 4.32,
  "valid_from": "2025-01-01",
  "valid_to": "2025-12-31",
  "is_active": true
}
Приклад відповіді 201:
{
  "created_at": "2025-12-25T05:14:11.901Z",
  "id": 10,
  "user_id": 2,
  "tariff_name": "Day tariff",
  "price_per_kwh": 4.32,
  "valid_from": "2025-01-01",
  "valid_to": "2025-12-31",
  "is_active": true
}
     6.7.3 Редагування тарифу
     Ендпоінт дозволяє змінювати назву тарифу, ціну, період дії та прапорець активності. Якщо під час оновлення тариф стає активним, система робить його єдиним активним для користувача й деактивує всі інші. Якщо тариф позначається активним, також перевіряється, що поточна дата входить у діапазон valid_from і valid_to.
Метод і шлях: PATCH /api/tariffs/{id}
Авторизація: потрібна.
У тіло запиту можна передавати будь-які з полів
tariff_name, price_per_kwh, valid_from, valid_to, is_active
Очікувані відповіді:
- 200, якщо тариф оновлено,
- 404, якщо тариф з таким id не знайдено у поточного користувача,
- 400, якщо порушено коректність дат або тариф не може бути активним на поточну дату.
Приклад запиту:
PATCH /api/tariffs/10
Authorization: Bearer <token>
Content-Type: application/json
{
  "price_per_kwh": 4.55,
  "valid_to": "2025-12-31"
}
Приклад відповіді 200:
{
  "id": 10,
  "user_id": 2,
  "price_per_kwh": 4.55,
  "tariff_name": "Day tariff",
  "valid_from": "2025-01-01",
  "valid_to": "2025-12-31",
  "is_active": true,
  "created_at": "2025-12-25T05:17:07.000Z"
}
     6.7.4 Активація тарифу окремим ендпоінтом
     Ендпоінт використовується, коли тариф уже створений, але потрібно зробити його активним. Якщо тариф уже активний, сервер просто повертає його без змін. Якщо тариф не активний, спочатку перевіряється можливість зробити його активним на поточну дату, після чого всі інші тарифи користувача деактивуються і вибраний тариф стає активним.
Метод і шлях: POST /api/tariffs/{id}/activate
Авторизація: потрібна.
Тіло запиту:
- id як число.
Очікувані відповіді:
- 200, якщо тариф активовано або вже був активним,
- 404, якщо тариф не знайдено у поточного користувача,
- 400, якщо тариф не може бути активним на поточну дату.
Приклад запиту:
POST /api/tariffs/5/activate
Authorization: Bearer <token>
Приклад відповіді 200:
{
  "id": 5,
  "user_id": 2,
  "price_per_kwh": "6.0000",
  "tariff_name": "Day tariff",
  "valid_from": "2025-01-01",
  "valid_to": "2025-12-31",
  "is_active": true,
  "created_at": "2025-12-24T20:44:33.000Z"
}
     6.7.5 Видалення тарифу
     Ендпоінт видаляє тариф поточного користувача. Використовується для очищення тестових даних або видалення неактуальних тарифів. Якщо id не належить поточному користувачу, повертається помилка not found.
Метод і шлях: DELETE /api/tariffs/{id}
Авторизація: потрібна.
Тіло запиту:
- id як число.
Очікувані відповіді:
- 204, якщо тариф видалено,
- 404, якщо тариф не знайдено у поточного користувача.
Приклад запиту:
DELETE /api/tariffs/10
Authorization: Bearer <token>
Приклад відповіді 204:
       тіло відповіді відсутнє
    7 Висновки
     У межах виконаної роботи було реалізовано серверну частину програмної системи контролю енергоспоживання у житлі. Обрана архітектура на базі Node.js з використанням Express.js дала змогу побудувати зрозумілу й розширювану структуру проєкту, де окремі модулі відповідають за автентифікацію, роботу з приладами, тарифами, записами споживання, лімітами та формуванням звітів. Такий підхід спростив підтримку коду, оскільки маршрути, бізнес правила та доступ до даних були логічно розділені й реалізовані послідовно для кожної сутності.
     Було спроєктовано модель даних і побудовано діаграми, які відобразили ключові сутності та їх зв’язки. На основі цього створено реляційну базу даних MySQL і підготовлено SQL скрипт, що відповідає фактичній реалізації. Адміністрування та перевірка структури таблиць виконувалися через phpMyAdmin у складі XAMPP, що дозволило швидко контролювати наявність полів, зовнішніх ключів, каскадних правил і коректність типів даних.
     Для доступу до БД використано ORM Sequelize, завдяки чому сервер працює з даними через моделі та запити у програмному вигляді. Це дало однаковий стиль операцій читання, створення, оновлення та видалення для всіх сутностей, а також дозволило реалізувати складніші сценарії, зокрема транзакційне перемикання активного тарифу, розрахунок вартості споживання за активним тарифом, перевірку перетинів лімітів та генерацію звітів з агрегуванням і групуванням.
     API було реалізовано у форматі REST з авторизацією через JWT. Специфікація ендпоінтів оформлена у Swagger, що забезпечило єдиний опис методів, шляхів, параметрів, форматів запитів і очікуваних відповідей. Перевірка роботи серверної частини виконувалась через Swagger UI шляхом послідовного виконання запитів для всіх модулів з тестовими даними, де контролювалася валідація дат, числових значень, доступність ресурсів та коректність обчислень у звітах.
     У результаті отримано працездатний серверний компонент, який забезпечує безпечне зберігання даних, контроль доступу, централізований розрахунок споживання і вартості, підтримку лімітів та аналітику за періодами.


ДОДАТОК А
Посилання на відео: https://youtu.be/c6lblHvxddg
