Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Звіт
з практичної роботи №2
з предмету «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу програмного коду»




Виконав: 
ст. гр. ПЗПІ 23-7
Варченко Микола Миколайович

Прийняв:
ст. викл. кафедри ПІ
Сокорчук І.П.






Харків 2025
     1.1 Мета
     Метою роботи є ознайомлення з основними методами рефакторингу, які дозволяють покращити внутрішню структуру програмного коду без зміни його зовнішньої поведінки. Досліджуються техніки зменшення складності, усунення надмірних умов, підвищення читабельності та покращення гнучкості системи. Окрему увагу приділено підходам Replace Type Code with State/Strategy, Replace Conditional with Polymorphism та Preserve Whole Object, а також принципам їх практичного застосування.
     1.2 Вступ
     Рефакторинг — це процес оптимізації коду, спрямований на структурні покращення без впливу на функціональні результати. Його задача — зробити проєкт простішим у підтримці, розширенні та модифікації.
У сучасній розробці рефакторинг відіграє ключову роль, оскільки:
• зменшує залежність від умовної логіки;
• допомагає запобігати появі «спагетті-коду»;
• полегшує командну роботу;
• підвищує стабільність архітектури під час майбутніх змін.
У роботі розглядаються три методи рефакторингу, кожен з яких спрямований на усунення типових недоліків у проєктуванні: дублювання логіки, перевантажені конструкції if/else, надмірні параметри та нечітка відповідальність класів.
     1.3 Хід роботи
Replace Type Code with State/Strategy
     Проблема
     У багатьох системах поведінка об’єкта визначається за допомогою певного "тип-коду" — числового або строкового значення.
Це призводить до:
• великих блоків if/else або switch;
• порушення принципу відкритості/закритості (OCP);
• складності у додаванні нових типів.
   
   Наприклад:
if (type == 1) { ... }
else if (type == 2) { ... }
else if (type == 3) { ... }
     Будь-яке доповнення потребує модифікації існуючого коду, що робить систему крихкою.
     Рішення
     Метод Replace Type Code with State/Strategy пропонує перемістити поведінку в окремі об'єкти-стратегії.
Кожен тип створюється як окремий клас зі спільним інтерфейсом, наприклад:
public interface IPaymentStrategy
{
    void Process();
}

public class CardPayment : IPaymentStrategy
{
    public void Process() { ... }
}

public class CashPayment : IPaymentStrategy
{
    public void Process() { ... }
}

public class CryptoPayment : IPaymentStrategy
{
    public void Process() { ... }
}
Тип більше не визначається числом — він представлений конкретним класом.
     Застосування
     Стратегія передається через інʼєкцію залежностей:
IPaymentStrategy strategy = new CardPayment();
var order = new Order(strategy);


Переваги:
• повне усунення умовної логіки,
• розширення без змін існуючого коду,
• зручність тестування,
• чіткий розподіл відповідальності.
Replace Conditional with Polymorphism
     Проблема
     У складніших системах поведінка залежить від ролі користувача, статусу замовлення, типу повідомлення тощо.
     У таких випадках знову з’являються довгі конструкції:
if (role == "admin") { ... }
else if (role == "doctor") { ... }
else if (role == "patient") { ... }
   Такі фрагменти:
• постійно розростаються;
• дублюють логіку;
• ускладнюють розширення (додавання нової ролі ламає існуючий код);
• суперечать принципам SOLID.
     Рішення
     Метод Replace Conditional with Polymorphism пропонує замінити умови абстрактним базовим класом, у якому описано спільний інтерфейс.
     Наприклад:
public abstract class User
{
    public abstract void AccessDashboard();
}

public class Admin : User
{
    public override void AccessDashboard() { ... }
}

public class Doctor : User
{
    public override void AccessDashboard() { ... }
}

public class Patient : User
{
    public override void AccessDashboard() { ... }
}
Усі умовні конструкції усуваються: логіка обирається за рахунок поліморфізму.
     Застосування
     Розробник працює виключно через базовий тип:
User user = new Doctor();
user.AccessDashboard();
Потрібний метод викликається автоматично відповідно до конкретного підкласу.
Код стає чистим, передбачуваним та стійким до змін.
Preserve Whole Object
     Проблема
     Коли методу передають лише окремі параметри об’єкта, виникають такі недоліки:
• втрачається контекст,
• збільшується кількість параметрів,
• зміни в моделі змушують переписувати всі виклики.
     Наприклад:
CalculateDiscount(user.Age, user.Status, user.Region);
Згодом до User можуть додатися нові властивості, і метод доведеться переробляти.
     Рішення
     Метод Preserve Whole Object закликає передавати цілісний об’єкт:
CalculateDiscount(user);
Переваги:
• спрощення сигнатур методів;
• менша залежність від структури даних;
• зменшення дублювання;
• стійкість до змін моделі.
     Застосування
     Код стає чистішим і зрозумілішим:
double discount = calculator.ApplyFor(user);
Якщо у моделі додаються поля, логіка працює без змін викликів функцій.
     1.4 Висновки
	У ході роботи було розглянуто ключові методи рефакторингу, які дозволяють покращити внутрішню структуру програмного коду без зміни його зовнішньої поведінки. Застосування підходів Replace Type Code with State/Strategy, Replace Conditional with Polymorphism та Preserve Whole Object сприяє зменшенню залежності від умовних конструкцій, підвищенню гнучкості системи та покращенню архітектури програмного забезпечення.
     Метод Replace Type Code with State/Strategy демонструє, як винесення поведінки в окремі стратегії усуває складні блоки умов і спрощує розширення системи новими сценаріями.
     Техніка Replace Conditional with Polymorphism забезпечує заміну багаторівневої логіки поліморфізмом, що робить код більш чистим, однорідним і легким у підтримці.
     Підхід Preserve Whole Object дозволяє зменшити кількість параметрів і зберегти цілісність моделі даних, що підвищує стійкість методів до майбутніх змін.
     Рефакторинг, виконаний за такими принципами, формує культуру створення якісного, зрозумілого та масштабованого програмного коду. Застосування цих технік у реальних проєктах підвищує стабільність системи та спрощує довготривалу підтримку програмного забезпечення.


Додаток А
Посилання на відео You-Tube
https://youtu.be/dAJ6_4IJyRw


Додаток Б
Скріншоти презентації

Рис.Б.1 – Титульний слайд


Рис.Б.2 – Огляд основних цілей рефакторингу


Рис.Б.3 – Приклад проблеми використання тип-кодів


Рис.Б.4 – Структурне розділення поведінки за допомогою стратегій


Рис.Б.5 – Принцип застосування стратегій у програмі


Рис.Б.6 – Проблеми умовної логіки у виборі поведінки


Рис.Б.7 – Побудова ієрархії класів для заміни умов


Рис.Б.8 – Використання поліморфізму для вибору дій


Рис.Б.9 – Недоліки передачі множини параметрів у методи


Рис.Б.10 – Переваги використання цілісних об’єктів у методах


Рис.Б.11 – Підсумок застосованих технік рефакторингу
