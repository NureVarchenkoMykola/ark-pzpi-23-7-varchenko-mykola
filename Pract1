
Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Звіт
з практичної роботи №1
з предмету «Аналіз та рефакторинг коду»
на тему «Правила оформлення програмного коду»




Виконав: 
ст. гр. ПЗПІ 23-7
Варченко Микола Миколайович

Прийняв:
ст. викл. кафедри ПІ
Сокорчук І.П.






Харків 2025
     1.1 Мета
     Метою роботи є вивчення та систематизація правил оформлення коду мовою програмування Go відповідно до стандартів Google Go Style Guide, а також закріплення практичних навичок написання чистого, структурованого та зрозумілого коду. Додатковою метою є ознайомлення з типовими помилками стилю та формування навичок їх уникнення під час розробки програмного забезпечення.
     1.2 Вступ
     Go (або Golang) — це сучасна мова програмування, створена в Google, яка поєднує продуктивність C-подібних мов із простотою синтаксису.
Для забезпечення єдиного стилю та читабельності коду розроблено офіційний документ — Google Go Style Guide. Його дотримання забезпечує зрозумілий, підтримуваний та ефективний код у командній розробці.
     1.3 Хід роботи
     Іменування
     У Go правила іменування впливають не тільки на зручність читання, а й на доступність об’єктів.
Видимість визначається першою літерою: великі літери використовують для елементів, доступних за межами пакета, а малі — для внутрішніх. Це дозволяє контролювати рівень доступу без додаткових ключових слів.
Рекомендується уникати складних назв та символів підкреслення.
Замість цього — короткі, інтуїтивні імена, які передають зміст.
Використання поширених скорочень, як ID, URL, є нормою.
Правильно:
type User struct {
    ID   int
    Name string
}

func GetName(u User) string {
    return u.Name
}
Неправильно:
type user_data struct {
    user_id   int
    user_name string
}

func get_user_name(u user_data) string {
    return u.user_name
}
     Структура та назви пакетів
     Пакет у Go — це логічна одиниця коду, яка має чітко визначену функцію.
Назва пакета повинна відображати його сутність: наприклад, auth, db, email.
Неприпустимі загальні назви на кшталт utils чи common, адже вони створюють безлад і не мають конкретного змісту.
Також не слід повторювати ім’я пакета в назвах структур або функцій.
Якщо пакет називається auth, достатньо створити тип User, а не AuthUser — контекст уже зрозумілий.
Правильно:
type User struct {
    Email string
    Pass  string
}

func Login(u User) bool {
    return u.Email != "" && u.Pass != ""
}

func main() {
    u := User{Email: "test@example.com", Pass: "1234"}
    fmt.Println("Авторизація:", Login(u))
}
Неправильно:
       type AuthUser struct {
           Email string
           Pass  string
       }
       func AuthLogin(u AuthUser) bool {
           return true
       }
       
       func main() {
           u := AuthUser{"test@example.com", "1234"}
           fmt.Println("Авторизація:", AuthLogin(u))
       }
     Коментарі
     Коментарі в Go є частиною офіційної документації, тому їх стиль має бути лаконічним і точним.
Кожен публічний тип, функція або метод повинні мати опис, який починається з імені сутності.
Це потрібно для того, щоб система godoc могла автоматично згенерувати документацію.
Коментар має пояснювати, чому код існує або як ним користуватися, а не повторювати його логіку.
Надмірні або очевидні коментарі зменшують якість коду.
Правильно:
// Add додає два числа та повертає результат.
func Add(a, b int) int {
    return a + b
}

func main() {
    fmt.Println(Add(3, 5))
}
Неправильно:
       // Ця функція додає два числа і повертає їхню суму.
       func Add(a, b int) int {
           return a + b
       }
       func main() {
           fmt.Println(Add(3, 5))
       }
     Форматування
     Go має вбудований інструмент gofmt, який забезпечує єдине форматування для всіх програм.
Він автоматично вирівнює відступи, розставляє пробіли, лапки й дужки у правильних місцях.
Це усуває будь-які суперечки між розробниками щодо стилю написання.
Перед завантаженням коду в репозиторій файл обов’язково має бути відформатований за допомогою gofmt або goimports.
Правильно:
func main() {
    x := 12
    if x > 10 {
        fmt.Println("Більше 10")
    }
}
Неправильно:
func main(){
x:=12
if(x>10){
fmt.Println("Більше 10")
}}
     Організація імпортів
     Під час імпорту бібліотек у Go діє суворий порядок.
Спочатку вказується стандартна бібліотека (fmt, time, os), далі — зовнішні пакети з GitHub чи інших джерел, а потім — внутрішні модулі проєкту.
Між цими групами ставлять один порожній рядок.
Цей підхід дозволяє швидко орієнтуватися у залежностях та спрощує підтримку коду.
Правильно:
import (
    "fmt"
    "time"

    "github.com/google/uuid"
)

func main() {
    id := uuid.New()
    fmt.Println("UUID:", id)
    fmt.Println("Час:", time.Now())
}
Неправильно:
import (
    "github.com/google/uuid"
    "fmt"
    "time"
)

func main() {
    fmt.Println(uuid.New(), time.Now())
}
     Оголошення змінних
     Go підтримує скорочену форму оголошення змінних — оператор :=, який дозволяє компілятору самостійно визначати тип.
Це робить код коротшим і чистішим.
Ключове слово var застосовується лише тоді, коли необхідно створити змінну з нульовим значенням або коли тип не може бути визначений автоматично.
Надмірне використання var робить код громіздким і менш зрозумілим.
Правильно:
func main() {
    count := 10
    name := "BumbleCare"

    var buf bytes.Buffer
    buf.WriteString("Hello, ")
    fmt.Println(buf.String()+name, count)
}
Неправильно:
func main() {
    var count int = 10
    var name string = "BumbleCare"
    fmt.Println(name, count)
}
     Обробка помилок
     Go не має класичної системи винятків, як у Java чи C#.
Замість цього використовується значення типу error, яке повертається разом із результатом функції.
Кожен виклик, що може спричинити помилку, потрібно перевіряти відразу після виконання.
Для додавання контексту застосовується fmt.Errorf з параметром %w, який дозволяє обгортати початкову помилку.
Такий підхід забезпечує прозорий ланцюг діагностики.
Використання panic дозволено лише у виняткових ситуаціях, коли програма не може продовжувати роботу.
Правильно:
func main() {
    file, err := os.Open("nonexistent.txt")
    if err != nil {
        fmt.Printf("Помилка: %v\n", err)
        return
    }
    defer file.Close()
}
Неправильно:
func main() {
    file, _ := os.Open("nonexistent.txt")
    defer file.Close()
}
     Функції та методи
     У Go функції мають бути короткими, виконувати лише одну задачу та бути логічно завершеними.
Якщо функція стає занадто довгою, її варто розділити на менші частини.
Також важливо розуміти різницю між вказівниковими та значеннєвими ресиверами у методах:
вказівниковий (*Type) використовується, коли метод змінює стан об’єкта,
а значеннєвий (Type) — коли об’єкт лише читається.
Це дозволяє економно працювати з пам’яттю та уникати неочікуваних побічних ефектів.
Правильно:
type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++
}

func (c Counter) Value() int {
    return c.value
}

func main() {
    c := Counter{}
    c.Increment()
    fmt.Println("Поточне значення:", c.Value())
}
Неправильно:
type Counter struct {
    value int
}

func (c Counter) Increment() {
    c.value++
}

func main() {
    c := Counter{}
    c.Increment()
    fmt.Println("Поточне значення:", c.value)
}
     
     Контекст і паралельність
     Однією з сильних сторін Go є підтримка конкурентності через горутини.
Проте будь-яка паралельна операція повинна мати контроль завершення.
Для цього використовується тип context.Context, який дозволяє керувати життєвим циклом процесів, встановлювати таймаути та виконувати скасування.
Використання контексту є стандартом у мережевому програмуванні та роботі з тривалими процесами.
Це забезпечує стабільність і передбачуваність програми навіть під час великої кількості одночасних запитів.
Правильно:
func main() {
    ctx, cancel := context.WithTimeout(
        context.Background(), 2*time.Second)
    defer cancel()

    req, _ := http.NewRequestWithContext(
        ctx, http.MethodGet, "https://example.com", nil)
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        fmt.Println("Помилка:", err)
        return
    }
    defer resp.Body.Close()
    fmt.Println("Статус:", resp.Status)
}
Неправильно:
func main() {
    go http.Get("https://example.com")
    time.Sleep(1 * time.Second)
    fmt.Println(
        "Програма завершилась до завершення запиту")
}
     Тестування
     Go має вбудовану систему тестування, яка дозволяє писати прості та структуровані тести без додаткових бібліотек.
Рекомендовано застосовувати табличний підхід, коли набір вхідних даних і очікуваних результатів задається у вигляді масиву структур.
Цей підхід зменшує дублювання коду і спрощує додавання нових випадків.
Імена тестових функцій мають починатися з Test, а повідомлення про помилки — бути зрозумілими і конкретними.
Правильно:
func main() {
    tests := []struct {
        a, b, want int
    }{
        {2, 3, 5},
        {-1, 1, 0},
    }

    for _, t := range tests {
        got := t.a + t.b
        if got != t.want {
            fmt.Printf("Помилка: %d + %d = %d; очікувалося %d\n", t.a, t.b, got, t.want)
        } else {
            fmt.Printf("ОК: %d + %d = %d\n", t.a, t.b, got)
        }
    }
}
Неправильно:
func main() {
    if 2+3 != 5 {
        fmt.Println("wrong")
    }
    if -1+1 != 0 {
        fmt.Println("wrong")
    }
}
     
     
     
     1.4 Висновки
     Єдиний стиль оформлення коду — це не формальність, а основа командної розробки. Дотримання стандартів Google Go Style Guide гарантує, що будь-який програміст зможе швидко розібратися в чужому коді.
Ці правила формують культуру написання якісного ПЗ, підвищують ефективність командної роботи та роблять проєкти на Go більш стабільними і професійними.


Додаток А
Посилання на відео You-Tube
https://youtu.be/Uq04-Mq9b2o


Додаток Б
Скріншоти презентації

Рис.Б.1 – Титульний слайд


Рис.Б.2 – Навіщо потрібні правила


Рис.Б.3 – Правило іменування


Рис.Б.4 – Структура та назви пакетів


Рис.Б.5 – Оформлення коментарів


Рис.Б.6 – Стандарт форматування


Рис.Б.7 – Оформлення імпортів


Рис.Б.8 – Правило оголошення змінних


Рис.Б.9 – Обробка помилок


Рис.Б.10 – Структура функцій та методів


Рис.Б.11 – Використання паралельності


Рис.Б.12 – Особливості тестування


Рис.Б.13 – Висновки
