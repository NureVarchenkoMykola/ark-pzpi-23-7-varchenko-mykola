Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Звіт
з лабораторної роботи №4
з предмету «Аналіз та рефакторинг коду»





Виконав: 
ст. гр. ПЗПІ 23-7
Варченко Микола Миколайович

Прийняв:
Дашенков Д.С.







Харків 2025
    1 Будова програмного забезпечення IoT клієнта
     Розроблений IoT клієнт реалізований на платформі ESP32 і працює як частина програмної системи контролю енергоспоживання. Він імітує реальний «розумний» прилад, який вмикає або вимикає навантаження, вимірює споживання електроенергії та передає результати на сервер через REST API, використовуючи JWT-автентифікацію. Для локального керування і візуалізації станів використано OLED-дисплей SSD1306, дві кнопки керування режимами, світлодіод індикації попереджень і бузер для звукових сигналів. У схемі присутнє реле, яке керує навантаженням, а навантаження в симуляції замінене LED з резистором як індикатор увімкненого стану.
     Функціонально IoT клієнт має два рівні роботи. Перший рівень є керуванням пристроєм у реальному часі, тобто обробкою кнопок, керуванням реле, накопиченням спожитої енергії та оновленням інтерфейсу на дисплеї. Цей рівень виконується у стандартному циклі loop. Другий рівень є мережевою взаємодією, тобто підключенням до Wi-Fi, отриманням JWT токена, відправкою записів споживання та періодичним опитуванням лімітів. Щоб мережеві операції не блокували основний цикл, вони винесені в окремий FreeRTOS-таск netTask, а обмін даними між loop і netTask виконано через черги FreeRTOS. Така будова робить клієнт стабільним, тому що навіть при затримках інтернету керування кнопками та відображення на екрані залишаються чутливими.
     У логіці є кілька ключових станів, які постійно синхронізуються між частинами програми. Зберігається стан реле, накопичена енергія поточної сесії, поточний режим роботи, стан блокування через перевищення ліміту, а також індикатори попередження та перевищення лімітів. OLED-дисплей показує на одному екрані всі важливі параметри, включно з Wi-Fi, наявністю JWT, режимом роботи, станом реле, потужністю, накопиченою енергією та максимальним відсотком використання ліміту, який отримано із сервера.
     
     
    2 Опис бізнес логіки та реалізації математичної обробки даних
     Бізнес логіка IoT клієнта побудована навколо моделі «сесії споживання». Сесія починається, коли користувач вмикає реле, і закінчується, коли користувач вимикає реле, або коли серверний ліміт споживання виявився перевищеним. Під час активної сесії пристрій регулярно «вимірює» потужність. У симуляції вона задається потенціометром і переводиться у значення кіловат у діапазоні від 0 до 2.5. Далі в кожній ітерації loop обчислюється інкремент енергії за формулою E += P * дельта(t), де P є потужністю в кіловатах, дельта(t) є часом між ітераціями у годинах, а E власне і є накопиченою енергією у кіловат-годинах. Таким чином реалізовано реальну фізичну залежність між потужністю, часом та енергією, що і є математичною частиною обробки даних у предметній області.
     Коли сесія завершується, накопичене значення енергії округлюється до тисячних і ставиться в чергу на відправку серверу. Передача реалізована через вже наявний серверний ендпоінт /api/consumption. IoT клієнт не змінює структуру бази даних і не потребує нових таблиць, оскільки він використовує існуючу модель ConsumptionRecord і записує лише ті поля, які сервер і так вміє обробляти. Пристроєм передається appliance_id як ідентифікатор приладу, consumption_kwh як підрахована енергія, record_date як поточна дата, і notes як службовий підпис, що запис створено ESP32. Уся вартість і тарифікація залишається відповідальністю бекенду. Ендпоінт /api/consumption сам знаходить активний тариф і розраховує cost.
     Додатковий шар бізнес логіки пов’язаний із контролем лімітів. Пристрій періодично опитує сервер щодо лімітів, які актуальні на сьогоднішню дату. Для цього використовується /api/limits?date=..., а далі для кожного знайденого ліміту викликається /api/limits/{id}/progress. На основі відповідей клієнт визначає, чи досягнуто поріг попередження, чи ліміт перевищено, і який максимальний відсоток використання серед усіх активних лімітів. Якщо сервер повідомляє про перевищення, клієнт переводить пристрій у захищений стан. У цьому стані реле блокується, а якщо навантаження було увімкнено, воно автоматично вимикається, сесія закінчується і запис споживання одразу відправляється на сервер. Так забезпечується концепція SmartDevice, де пристрій не лише збирає дані, а й приймає рішення на основі політик системи, заданих на сервері. Світлодіод попередження та бузер використовуються як локальне повідомлення користувачу, що наближено поріг або перевищено ліміт.
     Режими роботи потрібні для різних сценаріїв використання. У ручному режимі клієнт відправляє дані лише після завершення сесії. В автоматичному ж режимі, клієнт періодично відправляє проміжні значення споживання, очищаючи лічильник сесії, щоб сервер отримував оновлення частіше. Це наближає систему до реальної телеметрії, де пристрій регулярно репортує показники, а не лише після вимкнення.
    3 Фрагменти коду, пояснення реалізації та налаштування IoT клієнта
     Налаштування IoT клієнта у цій реалізації представлене набором констант, які визначають апаратні піни, параметри мережі, адресу бекенду, облікові дані користувача, ідентифікатор приладу та періоди опитування. Зміна цих значень не змінює бізнес логіку, але змінює середовище роботи пристрою, джерела даних та частоти обміну. Ось фрагмент налаштувань пінів і параметрів інтеграції з сервером:
       static const int PIN_POT = 34;
       
       static const int PIN_BTN_MODE = 12;
       static const int PIN_BTN_TOGGLE = 13;
       
       static const int PIN_RELAY_IN = 26;
       
       static const int PIN_BUZZER = 27;
       static const int PIN_LED_ALERT = 32;
       
       static const int PIN_I2C_SDA = 21;
       static const int PIN_I2C_SCL = 22;
       
       static const int OLED_W = 128;
       static const int OLED_H = 64;
       Adafruit_SSD1306 display(OLED_W, OLED_H, &Wire, -1);
       
       static const char* WIFI_SSID = "Wokwi-GUEST";
       static const char* WIFI_PASS = "";
       static const char* API_BASE = "https://ark-pzpi-23-7-varchenko-mykola.onrender.com";
       
       static const char* USER_EMAIL = "test2@mail.com";
       static const char* USER_PASSWORD = "password123";
       static const int APPLIANCE_ID = 1;
       
       static const uint32_t AUTO_SEND_PERIOD_MS = 30000;
       static const uint32_t LIMITS_POLL_PERIOD_MS = 10000;
     
     Цей код визначає, до яких GPIO підключені потенціометр, кнопки, реле, бузер і індикаторний LED. Далі задається Wi-Fi мережа Wokwi, базова URL-адреса бекенду Render і дані для логіна, які потрібні, щоб отримати JWT і робити авторизовані запити. Значення APPLIANCE_ID прив’язує показники саме до того приладу, який є в базі даних. Періоди AUTO_SEND_PERIOD_MS і LIMITS_POLL_PERIOD_MS задають частоту фонових дій.
     Ключова математична частина вимірювання потужності і підрахунку енергії реалізована через потенціометр та інтегрування у часі:
       static float readPowerKw() {
         int raw = analogRead(PIN_POT);
         float kw = (raw / 4095.0f) * 2.5f;
         if (kw < 0) kw = 0;
         return kw;
       }

       float powerKw = readPowerKw();
       
       if (gRelayOn) {
         double dtHours = (double)dtMs / 3600000.0;
         sessionKwh += (double)powerKw * dtHours;
       }
     Спочатку зчитується ADC значення від 0 до 4095 і масштабується до діапазону потужності. Далі при увімкненому реле енергія наростає як добуток потужності на час у годинах. Так формується sessionKwh, яка йде на сервер як consumption_kwh.
     Фрагмент, що показує, як організовано автентифікацію та отримання JWT, виглядає так:
       static bool apiLogin() {
         StaticJsonDocument<256> doc;
         doc["email"] = USER_EMAIL;
         doc["password"] = USER_PASSWORD;
       
         String body;
         serializeJson(doc, body);
       
         HttpResp r = httpJson("POST", "/api/auth/login", body, false);
         if (r.status != 200) {
           Serial.print("Login failed: ");
           Serial.print(r.status);
           Serial.print(" body=");
           Serial.println(r.body);
           return false;
         }
       
         StaticJsonDocument<512> resp;
         if (deserializeJson(resp, r.body)) return false;
       
         const char* token = resp["token"];
         if (!token || String(token).length() == 0) return false;
       
         gToken = String(token);
         Serial.println("Login OK");
         return true;
       }
     Тут формується JSON тіло, виконується POST на /api/auth/login і з відповіді дістається token. Далі він зберігається в gToken і використовується для заголовка Authorization у наступних запитах.
     Фрагмент відправки споживання демонструє пряме використання існуючого ендпоінта /api/consumption без змін на бекенді:
       static bool apiPostConsumption(double kwh) {
         StaticJsonDocument<512> doc;
         doc["appliance_id"] = APPLIANCE_ID;
         doc["consumption_kwh"] = kwh;
         doc["record_date"] = todayISO();
         doc["notes"] = "ESP32 session";
       
         String body;
         serializeJson(doc, body);
       
         HttpResp r = httpJson("POST", "/api/consumption", body, true);
         if (r.status == 201) return true;
       
         Serial.print("Post consumption failed: ");
         Serial.print(r.status);
         Serial.print(" body=");
         Serial.println(r.body);
       
         if (r.status == 401) {
           gToken = "";
           if (apiLogin()) {
             HttpResp r2 = httpJson("POST", "/api/consumption", body, true);
             return r2.status == 201;
           }
         }
         return false;
       }
     Запис створюється з appliance_id, підрахованим consumption_kwh, поточною датою та приміткою. Якщо сервер повертає 401, клієнт автоматично перелогінюється і повторює запит. Це важлива частина налаштування надійності, тому що IoT-пристрій має працювати автономно без ручного втручання.
     
     Фрагмент, що реалізує взаємодію з серверними лімітами і перетворює їх у локальні рішення, є центральним для SmartDevice-поведінки:
       static void apiPollAllLimitsProgress() {
         String path = "/api/limits?date=" + todayISO();
         HttpResp r = httpJson("GET", path, "", true);
       
         if (r.status == 401) {
           gToken = "";
           if (apiLogin()) {
             r = httpJson("GET", path, "", true);
           }
         }
         if (r.status != 200) return;
       
         DynamicJsonDocument listDoc(4096);
         if (deserializeJson(listDoc, r.body)) return;
         if (!listDoc.is<JsonArray>()) return;
       
         bool thrAny = false;
         bool excAny = false;
         float maxPct = -1.0f;
         for (JsonObject lim : listDoc.as<JsonArray>()) {
           int id = lim["id"] | -1;
           if (id <= 0) continue;
       
           String p = "/api/limits/" + String(id) + "/progress";
           HttpResp pr = httpJson("GET", p, "", true);
           if (pr.status != 200) continue;
       
           DynamicJsonDocument pd(2048);
           if (deserializeJson(pd, pr.body)) continue;
       
           float pct = pd["percent_used"] | -1.0f;
           bool thr = pd["threshold_reached"] | false;
           bool exc = pd["limit_exceeded"] | false;
       
           if (pct > maxPct) maxPct = pct;
           thrAny = thrAny || thr;
           excAny = excAny || exc;
         }
         portENTER_CRITICAL(&gMux);
         gAnyThreshold = thrAny;
         gAnyExceeded = excAny;
         gMaxPercentUsed = maxPct;
         gAlertOn = thrAny || excAny;
         gLimitBlocked = excAny;
       
         if (excAny) gForceStop = true;
         portEXIT_CRITICAL(&gMux);
       }
     Спочатку знаходяться ліміти на сьогодні, далі по кожному ліміту запитується прогрес. У результаті формується глобальна картина, чи є попередження і чи є перевищення. Якщо є перевищення, gLimitBlocked блокує ручне вмикання реле, а gForceStop запускає примусове вимкнення, якщо навантаження було увімкнене. Це перетворює серверні політики у локальні дії пристрою.
     Керування кнопками та усунення брязкоту контактів реалізоване дебаунсом, щоб натискання були стабільними:
       static bool buttonPressed(Button& b) {
         const uint32_t now = millis();
         const bool rawPressed = (digitalRead(b.pin) == LOW);
       
         if (rawPressed != b.lastRaw) {
           b.lastRaw = rawPressed;
           b.lastChangeMs = now;
         }
       
         if ((now - b.lastChangeMs) > 40) {
           if (b.lastStable != rawPressed) {
             b.lastStable = rawPressed;
             if (b.lastStable) return true;
           }
         }
         return false;
       }
     У цьому фрагменті натискання вважається дійсним тільки тоді, коли сигнал стабільний певний час. Це критично для керування режимом і реле, щоб не було випадкових перемикань.
     Окремий мережевий FreeRTOS-таск є прикладом внутрішньої будови IoT клієнта, де дані з основного циклу передаються у фоновий процес через черги:
       static void netTask(void*) {
         uint32_t lastPollMs = 0;
       
         for (;;) {
           if (!wifiConnected()) {
             vTaskDelay(pdMS_TO_TICKS(300));
             continue;
           }
       
           NetCmd cmd;
           while (qCmd && xQueueReceive(qCmd, &cmd, 0) == pdTRUE) {
             if (cmd.type == CMD_LOGIN) {
               apiLogin();
             } else if (cmd.type == CMD_POLL_LIMITS) {
               apiPollAllLimitsProgress();
             }
           }
       
           if (gToken.length() == 0) {
             apiLogin();
           }
       
           double kwh = 0.0;
           if (qSend && xQueueReceive(qSend, &kwh, pdMS_TO_TICKS(50)) == pdTRUE) {
             portENTER_CRITICAL(&gMux);
             gSending = true;
             portEXIT_CRITICAL(&gMux);
       
             apiPostConsumption(kwh);
       
             portENTER_CRITICAL(&gMux);
             gSending = false;
             portEXIT_CRITICAL(&gMux);
           }
       
           uint32_t now = millis();
           if (now - lastPollMs > LIMITS_POLL_PERIOD_MS) {
             lastPollMs = now;
             apiPollAllLimitsProgress();
           }
       
           vTaskDelay(pdMS_TO_TICKS(10));
         }
       }
     Цей код відповідає за регулярні мережеві дії, при цьому loop не блокується. Через це дисплей і кнопки працюють плавно навіть тоді, коли HTTP запити повільні.
    4 Графічні ілюстрації 
     4.1 UML діаграма прецедентів IoT клієнта
     Діаграма прецедентів відображає основні сценарії використання IoT клієнта на базі ESP32 у складі програмної системи обліку енергоспоживання. На ній показано взаємодію двох акторів, якими є користувач та серверна система. Користувач керує локальною поведінкою пристрою через кнопки, обирає режим роботи та керує навантаженням через реле. Серверна система забезпечує автентифікацію (отримання JWT), приймання даних споживання та надання стану лімітів, які використовуються для формування попереджень і блокування навантаження при перевищенні. Діаграма також демонструє, що індикація на дисплеї та звуково-світлові попередження пов’язані зі станом лімітів і поточним режимом, а мережеві дії підтримують локальну частину керування, забезпечуючи передачу накопичених даних і отримання актуального статусу з сервера.

Рис.1 – UML діаграма прецедентів IoT клієнта
     4.2 UML діаграма діяльності IoT клієнта
     Діаграма діяльності описує логіку виконання IoT клієнта як процес, що складається з ініціалізації та двох узгоджених гілок роботи. Після старту відбувається ініціалізація ESP32 і периферії, підключення до Wi-Fi та запуск окремого мережевого завдання. В основному циклі виконується періодичне зчитування потужності з потенціометра та розрахунок накопиченої енергії сесії під час увімкненого реле. Далі обробляються події натискання кнопок, що відповідають за перемикання режиму роботи та увімкнення або вимкнення навантаження з урахуванням блокування при перевищенні ліміту. У разі перевищення ліміту формується примусове вимкнення реле, збереження та відправлення даних сесії і подання попередження. В автоматичному режимі додатково виконується періодична відправка проміжних даних сесії, щоб споживання фіксувалося у системі частинами. Паралельно мережевий процес забезпечує актуальність авторизації, отримання JWT при необхідності, відправлення накопичених даних споживання на сервер та регулярне опитування лімітів, після чого оновлюються прапори попереджень, блокування і стан індикації. У підсумку діаграма показує повний життєвий цикл роботи клієнта та взаємодію локального керування з мережевою синхронізацією.

Рис.2 – UML діаграма діяльності IoT клієнта
     4.3 IoT клієнт системи контролю енергоспоживання
     IoT клієнт побудовано на мікроконтролері ESP32 та інтегровано з серверною частиною через REST API. Схема включає потенціометр для симуляції вимірювання потужності, дві кнопки керування, дисплей для відображення стану, модуль реле для комутації навантаження, світлодіод попередження та п'єзобузер. Пристрій самостійно обчислює споживання енергії, відправляє дані на сервер, отримує інформацію про ліміти та блокує реле при їх перевищенні, реалізуючи концепцію розумного керування навантаженням на базі серверних політик. 


Рис.3 – IoT клієнт системи контролю енергоспоживання на базі ESP32

ДОДАТОК А
Посилання на відео: https://youtu.be/KY8yLXN2GZ8
